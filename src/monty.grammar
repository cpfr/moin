{
    Array.prototype.peek = function(){
        return this[this.length-1];
    }

    function strPos(){
        var loc = location();
        return loc.start.line+":"+
                    loc.start.column+" - "+
                    loc.end.line+":"+
                    loc.end.column;
    }

    function Pos(line, column){
        this.line = line;
        this.column = column;

        this.toString = function(){
            return "line "+this.line+", column "+this.column;
        }
    }
    this.createPos = function(line, column){
        return new Pos(line, column);
    }

    // ---------------------------------------------------------------
    // ---------------------------------------------------------------
    
    function Node(pos, endPos, name){
        this.pos = pos;
        this.endPos = endPos;
        this.name = name;

        this.toString = function(){
            return this.name + " at " + this.pos.toString();
        }

        this.isDeclaration = function(){return false;};
        this.isStatement = function(){return false;};
        this.isExpression = function(){return false;};
    }

    // ---------------------------------------------------------------
    
    Declaration.prototype = new Node();
    Declaration.prototype.constructor = Declaration;
    function Declaration(pos, endPos, visibility){
        this.pos = pos;
        this.endPos = endPos;
        this.name = "Declaration";
        this.visibility = visibility || "~";

        this.isDeclaration = function(){return true;};
    }

    // ---------------------------------------------------------------
    
    Statement.prototype = new Node();
    Statement.prototype.constructor = Statement;
    function Statement(pos, endPos){
        this.pos = pos;
        this.endPos = endPos;
        this.name = "Statement";

        this.isStatement = function(){return true;};
    }

    // ---------------------------------------------------------------
    
    Expression.prototype = new Node();
    Expression.prototype.constructor = Expression;
    function Expression(pos, endPos, value){
        this.pos = pos;
        this.endPos = endPos;
        this.name = "Expression";
        this.value = value || undefined;

        var self = this;
        this.isExpression = function(){return true;};
        this.getValue = function(){ return self.value; }
    }

    this.createExpression = function (pos, endPos, value){
        return new Expression(pos, endPos, value);
    }

    // ---------------------------------------------------------------
    // ---------------------------------------------------------------
    
    WhileLoop.prototype = new Statement();
    WhileLoop.prototype.constructor = WhileLoop;
    function WhileLoop(pos, endPos, condition, body){
        this.name = "WhileLoop";
        this.pos = pos;
        this.endPos = endPos;
        this.condition = condition;
        this.body = body;
    }

    // ---------------------------------------------------------------
    
    IfStatement.prototype = new Statement();
    IfStatement.prototype.constructor = IfStatement;
    function IfStatement(pos, endPos, condition, trueBody, falseBody){
        this.name = "IfStatement";
        this.pos = pos;
        this.endPos = endPos;
        this.condition = condition;
        this.trueBody = trueBody;
        this.falseBody = falseBody;
    }

    // ---------------------------------------------------------------
    
    MtyObject.prototype = new Expression();
    MtyObject.prototype.constructor = MtyObject;
    function MtyObject(pos, endPos, block, type){
        this.name = "MtyObject";
        this.pos = pos;
        this.endPos = endPos;
        this.block = block;
        this.type = type || null;

        this.getValue = function(){
            return this;
        }
    }

    this.createObject = function(pos, endPos, block, type){
        return new MtyObject(pos, endPos, block, type);
    }
    // ---------------------------------------------------------------
    
    SelfExpression.prototype = new Expression();
    SelfExpression.prototype.constructor = SelfExpression;
    function SelfExpression(pos, endPos, value, type){
        this.name = "SelfExpression";
        this.pos = pos;
        this.endPos = endPos;
        this.value = value;
        this.type = type || null;

        this.getValue = function(){
            return this.value;
        }
    }

    // ---------------------------------------------------------------
    
    Literal.prototype = new Expression();
    Literal.prototype.constructor = Literal;
    function Literal(pos, endPos, value, type){
        this.name = "Literal";
        this.pos = pos;
        this.endPos = endPos;
        this.value = value;
        this.type = type || null;

        this.getValue = function(){
            return this.value;
        }
    }

    // ---------------------------------------------------------------
    
    FunctionCall.prototype = new Expression();
    FunctionCall.prototype.constructor = FunctionCall;
    function FunctionCall(pos, endPos, functionName, parameters, type){
        this.name = "FunctionCall";
        this.pos = pos;
        this.endPos = endPos;
        this.functionName = functionName;
        this.parameters = parameters;
        this.type = type || null;
        /* FIXME: brauche ich type?*/

        /* function calls are also statements */
        this.isStatement = function(){return true;};
    }

    this.createFunctionCall = function(pos, endPos, functionName, parameters,
                                    type){
        return new FunctionCall(pos, endPos, functionName, parameters, type);
    }

    // ---------------------------------------------------------------
    
    MethodCall.prototype = new Expression();
    MethodCall.prototype.constructor = MethodCall;
    function MethodCall(memberAccess){
        this.memberAccess = memberAccess;
        this.name = "MethodCall";
        this.pos = memberAccess.pos;
        this.endPos = memberAccess.endPos;
        this.isStatement = function(){return true;};
    }

//    this.createMethodCall = function(pos, endPos, functionName, parameters,
//                                    type){
//        return new FunctionCall(pos, endPos, functionName, parameters, type);
//    }

    // ---------------------------------------------------------------
    
    VariableDeclaration.prototype = new Declaration();
    VariableDeclaration.prototype.constructor = VariableDeclaration;
    function VariableDeclaration(pos, endPos, varName, type, constant){
        this.name = "VariableDeclaration";
        this.pos = pos;
        this.endPos = endPos;
        this.variableName = varName;
        this.type = type;
        this.constant = constant || false;
        this.value = undefined;

        this.getValue = function(){
            return this.value;
        }
    }

    // ---------------------------------------------------------------
    
    FunctionDeclaration.prototype = new Declaration();
    FunctionDeclaration.prototype.constructor = FunctionDeclaration;
    function FunctionDeclaration(pos, endPos, funName, params, returnType, body){
        this.name = "FunctionDeclaration";
        this.pos = pos;
        this.endPos = endPos;
        this.functionName = funName;
        this.parameters = params;
        this.returnType = returnType;
        this.body = body;
    }

    // ---------------------------------------------------------------
    
    ClassDeclaration.prototype = new Declaration();
    ClassDeclaration.prototype.constructor = ClassDeclaration;
    function ClassDeclaration(pos, endPos, clsName, superClasses, members,
                            abstract){
        this.name = "ClassDeclaration";
        this.pos = pos;
        this.endPos = endPos;
        this.className = clsName;
        this.superClasses = superClasses;
        this.block = new Block(this.pos, this.endPos, members, "class");
        this.abstract = abstract || false;

        this.createInstance = function(callNode){
            var contents = [];
            for(var name in this.block._variableDeclarations){
                var member = this.block._variableDeclarations[name];
                contents.push(new VariableDeclaration(member.pos,
                                                    member.endPos,
                                                    member.variableName,
                                                    member.type,
                                                    member.constant));
            }
            for(var name in this.block._functionDeclarations){
                var member = this.block._functionDeclarations[name];
                contents.push(new FunctionDeclaration(member.pos,
                                                    member.endPos,
                                                    member.functionName,
                                                    member.parameters,
                                                    member.returnType,
                                                    member.body));
            }
            // statements do not have to be copied
            for(var i = 0; i < this.block.statements.length; i++){
                contents.push(this.block.statements[i]);
            }
            var body = new Block(this.pos, this.endPos, contents, "class");
            return new MtyObject(callNode.pos, callNode.endPos, body,
                                this.className);
        }
    }

    // ---------------------------------------------------------------
    
    VariableAccess.prototype = new Expression();
    VariableAccess.prototype.constructor = VariableAccess;
    function VariableAccess(pos, endPos, varName){
        this.name = "VariableAccess";
        this.pos = pos;
        this.endPos = endPos;
        this.variableName = varName;
    }

    this.createVariableAccess = function(pos, endPos, varName){
        return new VariableAccess(pos, endPos, varName);
    }

    // ---------------------------------------------------------------
    
    Assignment.prototype = new Statement();
    Assignment.prototype.constructor = Assignment;
    function Assignment(pos, endPos, left, right){
        this.name = "Assignment";
        this.pos = pos;
        this.endPos = endPos;
        this.left = left;
        this.right = right;
    }

    this.createAssignment = function(pos, endPos, left, right){
        return new Assignment(pos, endPos, left, right);
    }

    // ---------------------------------------------------------------
    
    CommandStatement.prototype = new Statement();
    CommandStatement.prototype.constructor = CommandStatement;
    function CommandStatement(pos, endPos, command, argument){
        this.name = "CommandStatement";
        this.pos = pos;
        this.endPos = endPos;
        this.command = command;
        this.argument = argument;
    }


    // ---------------------------------------------------------------

    Block.prototype = new Node();
    Block.prototype.constructor = Block;
    function Block(pos, endPos, contents, blockType){
        this.name = "Block";
        this.pos = pos;
        this.endPos = endPos;
        this.statements = [];
        this.blockType = blockType;
        contents = contents || [];

        this._variableDeclarations = {};
        this._functionDeclarations = {};
        this._classDeclarations = {};

        var self = this;
        this.addContents = function(contents){
            for(var i = 0; i < contents.length; i++){
                if(Array.isArray(contents[i])){
                    self.addContents(contents[i]);
                }
                else{
                    if(contents[i].isDeclaration()){
                        var decl = contents[i];
                        if(decl.variableName !== undefined){
                            this._variableDeclarations[decl.variableName] = decl;
                        }
                        else if(decl.functionName !== undefined){
                            this._functionDeclarations[decl.functionName] = decl;
                        }
                        else if(decl.className !== undefined){
                            this._classDeclarations[decl.className] = decl;
                        }
                    }
                    else if(contents[i].isStatement()){
                        self.statements.push(contents[i]);
                    }
                    else{
                        console.log("Error, invalid content: "+contents[i]);
                    }
                }
            }
        }
        self.addContents(contents);

        this.resolveVariable = function(varname){
            return this._variableDeclarations[varname];
        }

        this.resolveFunction = function(funname){
            return this._functionDeclarations[funname];
        }

        this.resolveClass = function(clsname){
            return this._classDeclarations[clsname];
        }
    }

    this.createBlock = function(pos, endPos, contents, blockType){
        return new Block(pos, endPos, contents, blockType);
    }

    // ---------------------------------------------------------------
    
    UnaryExpression.prototype = new Expression();
    UnaryExpression.prototype.constructor = UnaryExpression;
    function UnaryExpression(pos, endPos, op, value){
        this.name = "UnaryExpression";
        this.pos = pos;
        this.endPos = endPos;
        this.op = op;
        this.value = value;
    }

    BinaryExpression.prototype = new Expression();
    BinaryExpression.prototype.constructor = BinaryExpression;
    function BinaryExpression(pos, endPos, left, op, right){
        this.name = "BinaryExpression";
        this.pos = pos;
        this.endPos = endPos;
        this.left = left;
        this.op = op;
        this.right = right;
    }

    // ---------------------------------------------------------------

    function getCurrentPos(){
        var loc = location();
        return new Pos(loc.start.line, loc.start.column);
    }

    function getCurrentEndPos(){
        var loc = location();
        return new Pos(loc.end.line, loc.end.column);
    }

    // ---------------------------------------------------------------

    function leftAssociative(lefts, right) {
        if (!lefts.length) return right;
        var last = lefts.pop();
        return new BinaryExpression(last.pos, last.endPos,
            leftAssociative(lefts, last.exp), last.op, right);
    }

    function rightAssociative(left, rights) {
        if (!rights.length) return left;
        var first = rights.shift();
        return new BinaryExpression(first.pos, first.endPos,
            left, first.op, rightAssociative(first.exp, rights));
    }
    
    // ---------------------------------------------------------------

    // ---------------------------------------------------------------
    // -- Indentation & White-Spaces ---------------------------------
    // ---------------------------------------------------------------
    var indentStack = [""];
    var nextIsIndent = false;
    var dedentCount = 0;

    // ---------------------------------------------------------------
    // -- Integer Literals -------------------------------------------
    // ---------------------------------------------------------------

    function convertToInt(str, base){
        str = str.toUpperCase();
        base = base || 10;
        if((base < 0)||(base > 36)){
            return NaN;
        }
    
        var current = str.charCodeAt(0);
        var result = current > 57 ? current-55 : current-48;
        if((result > base) || (result < 0)){
            return NaN;
        }
        var len = str.length;
        for (var i=1; i < len; i++){
            result *= base;
            current = str.charCodeAt(i)
            var value = current > 57 ? current-55 : current-48;
            if((value > base) || (value < 0)){
                return NaN;
            }
            result += value;
        }
        return result;
    }


    // ---------------------------------------------------------------
    // -- String Literals --------------------------------------------
    // ---------------------------------------------------------------

    function getStringEscapeValue(escapeSequence){
        switch(escapeSequence){
            case "\\t":
                return "\t";
            case "\\b":
                return "\b";
            case "\\n":
                return "\n";
            case "\\r":
                return "\r";
            case "\\f":
                return "\f";
            case "\\'":
                return "'";
            case "\\\"":
                return "\"";
            case "\\\\":
                return "\\";
        }
        var numCount = 0;
        if(escapeSequence.charAt(1) == "x"){
            numCount = 2;
        }
        else if(escapeSequence.charAt(1) == "u"){
            numCount = 4;
        }
        return String.fromCharCode(parseInt(escapeSequence.substr(2, numCount), 16));
    }
    
    function flattenStringLiteral(obj, raw){
        raw = raw || false;
        var len = obj.length;
        var output = "";
        var current;
        for(var i = 0; i < len; i++){
            current = obj[i];
            if(current === undefined){
                continue;
            }
            if(Array.isArray(current)){
                output += flattenStringLiteral(current, raw);
            }
            else if((!raw)&&(current.startsWith("\\"))){
                output += getStringEscapeValue(current);
            }
            else{
                output += current;
            }
        }
        return output;
    }

    function createNestedIfElifStatements(ifelifs, elseblock){
        if(ifelifs.length == 0){
            return elseblock || new Block(new Pos(-1,-1),new Pos(-1,-1));
        }
        var ifobj = ifelifs.shift();
        return new IfStatement(ifobj.pos, ifobj.endPos, ifobj.condition,
            ifobj.body, createNestedIfElifStatements(ifelifs, elseblock));
    }
}

// -------------------------------------------------------------------
// -- The Grammar ----------------------------------------------------
// -------------------------------------------------------------------

/*start = _begin*/

moduleDeclaration = /*importLine* */
    contents:(classDeclaration / statement)*
    { return new Block(getCurrentPos(),
        getCurrentEndPos(),
        contents, "module");
    }

declaration = independentDeclaration
            / classDeclaration
            /*/ caseClassDeclaration
            / generatorDeclaration*/

declWithAssignment = vardecl:(variableDeclaration / constantDeclaration)
                        _ ':=' _ value:expression
                            {
                                return [
                                    vardecl,
                                    new Assignment(getCurrentPos(),
                                        getCurrentEndPos(),
                                        new VariableAccess(vardecl.pos,
                                                        vardecl.endPos,
                                                        vardecl.variableName),
                                        value)
                                    ];
                            }

independentDeclaration = functionDeclaration
                        / (decl:(declWithAssignment
                            / constantDeclaration
                            / variableDeclaration) EOL
                            { return decl; }
                            )
                        

classDeclaration = abstract:('abstract' _)? 'class' _nonchar_ _
                    className:type superClasses:( _nonchar_ _ 'inherits'
                                            _nonchar_ _
                                            types:typeList {return types;})?
                    ':' EOL INDENT _

                    members: (('pass' EOL {return [];})
                    / ( firstMember:memberDeclaration
                        members:((SAMEDENT m:memberDeclaration {return m;})*)
                        {members.unshift(firstMember); return members;}))
                    _ DEDENT
                    {
                        return new ClassDeclaration(getCurrentPos(),
                            getCurrentEndPos(),
                            className, superClasses, members, abstract!=null);
                    }
/*
block = ':' EOL INDENT
            firstStatement:(statement / 'pass' EOL {return null;})
            statements:(SAMEDENT _ stmt:statement {return stmt;})* DEDENT
        {
            var body = []
            if(firstStatement){
                body.push(firstStatement);
            }
            if(Array.isArray(statements)){
                body = body.concat(statements);
            }
            return new Block(getCurrentPos(), getCurrentEndPos(), body);
        }
*/

/*caseClassDeclaration
  : 'case' 'class' type '(' (parameterListWithoutDefaults)? ')' ('inherits' typeList)?
    (':' EOL
    INDENT
        (memberDeclaration+ / 'pass' EOL)
    DEDENT)?
  ;*/

memberDeclaration = visibility:accessModifier? _
                    decl:(independentDeclaration / abstractMethodDeclaration)
                    {
                        var member = decl;
                        if(visibility != null){
                            member.visibility = visibility;
                        }
                        return member;
                    }

abstractMethodDeclaration = 'abstract' ret:type? name:Identifier
                            Lparenthesis params:parameterList? Rparenthesis EOL

accessModifier = '#' / '+' / '-' / '~'

variableDeclaration = type:type _ varname:Identifier
                    {
                        return new VariableDeclaration(getCurrentPos(),
                            getCurrentEndPos(), varname, type);
                    }
constantDeclaration = type:type _ varname:ConstantIdentifier
                    {
                        return new VariableDeclaration(getCurrentPos(),
                            getCurrentEndPos(), varname, type, true);
                    }

type = ClassIdentifier
      /*('<' typeList '>')?
      / '(' (type (',' type)+)? ')'
      / type '->' type
      / '(' type '->' type ')'
      */

typeList = head:type tail:((',' _ type)*)
            {
                var list = [head];
                for(var i=0; i < tail.length; i++){
                    list.push(tail[i][2]);
                }
                return list;
            }


functionDeclaration = ret:(type?) _ name:Identifier
            Lparenthesis params:parameterList? Rparenthesis
            body:block
            {
                body.blockType = "function";
                return new FunctionDeclaration(getCurrentPos(),
                                                getCurrentEndPos(),
                                                name, params, ret, body);
            }

/*generatorDeclaration
    : 'generator' type
      ClassIdentifier
      Lparenthesis parameterList? Rparenthesis 
      block
    ;
*/

parameterList = defaultParameterList
                / (params:parameterListWithoutDefaults
                    defaults:(',' _ def:defaultParameterList {return def;})?
                        {
                            var list = params;
                            if(defaults != null){
                                list = list.concat(defaults);
                            }
                            return list;
                        }
                    )

parameterListWithoutDefaults = head:variableDeclaration !( _ ':=')
                                tail:((',' _ vd:variableDeclaration !( _ ':=') _
                                    {return vd;})*)
            {
                var list = [head];
                if(tail != null){
                    list = list.concat(tail);
                }
                return list;
            }

defaultParameterList = head:declWithAssignment
                        tail:((',' _ declWithAssignment _)*)
            {
                var list = [head];
                for(var i=0; i < tail.length; i++){
                    list.push(tail[i][1]);
                }
                return list;
            }

statement = declaration
        / methodCallStm
        / functionCallStm
        / whileStatement
        // forStatement
        / ifStatement
        // tryStatement
        // unpackAssignment
        / assignment
        / compoundAssignment
        / functionCallStm
        / stmWithEOL
        // caseStatement

functionCallStm = call:functionCall EOL { return call; }
methodCallStm = m:memberAccess EOL
                &{
                    var node = m;
                    while(node.right != undefined){
                        if(node.right.name == "FunctionCall"){
                            return true;
                        }
                        else{
                            node = node.right;
                        }
                    }
                    return false;
                }
                {
                    return new MethodCall(m);
                }



stmWithEOL = stm:commandStm EOL {return stm;}
            / left:expression operator:'.' right:functionCall EOL

commandStm = (cmd:('return' / 'yield' / 'raise') _nonchar_ _ exp:expression?
                { return new CommandStatement(getCurrentPos(),
                    getCurrentEndPos(), cmd, exp); })
            / ( cmd:('skip' / 'break')
                { return new CommandStatement(getCurrentPos(),
                    getCurrentEndPos(), cmd, null); })

/* while loop: The expression must be a condition (i.e. Boolean expression). */
whileStatement = 'while' _nonchar_ _ cond:expression _ body:block
                { body.blockType = "loop";
                return new WhileLoop(getCurrentPos(),
                    getCurrentEndPos(), cond, body); }

/* for loop: The expression must be of type Iterable<T>. */
/* forStatement = 'for' Identifier 'in' expression block */

ifStatement = 'if' _nonchar_ _ cond:expression _ thenBlock:block
                elifs:elif* elseBlock:('else' _ eb:block { return eb; })?
    {
        var ifelifs = elifs;
        ifelifs.unshift({
                    condition: cond,
                    body: thenBlock,
                    pos: getCurrentPos(),
                    endPos : getCurrentEndPos()
                });
        return createNestedIfElifStatements(ifelifs, elseBlock);
    }

elif = 'elif' _nonchar_ _ elifCondition:expression _ elifBlock:block
        {
            return {
                    condition: elifCondition,
                    body: elifBlock,
                    pos: getCurrentPos(),
                    endPos : getCurrentEndPos()
                };
        }

/*tryStatement = 'try' block
    ('handle' variableDeclaration? handleBlock:block)+ */

assignment = left:expression _ ':=' _ right:expression EOL
            { return new Assignment(getCurrentPos(), getCurrentEndPos(),
                left, right); }

/*unpackAssignment = left:unpackList ':=' right:expression EOL
unpackList = unpackable (',' unpackable)+
unpackable = expression / variableDeclaration */

compoundAssignment = left:expression _ op:compoundSymbol '='
                    _ right:expression EOL
            {
                var compound = new BinaryExpression(getCurrentPos(),
                    getCurrentEndPos(), left, op, right);
                return new Assignment(getCurrentPos(), getCurrentEndPos(),
                    left, compound);
            }

compoundSymbol = '+' / '-' / '*' / '/' / '%' / '^'


functionCall = funName:(type / Identifier)
                Lparenthesis params:expressionList? Rparenthesis
                {
                    params = params || [];
                    return new FunctionCall(getCurrentPos(),
                        getCurrentEndPos(), funName, params);
                }
expressionList = head:expression tail:((',' _ exp:expression _ {return exp;})*)
            {
                var list = [head];
                for(var i=0; i < tail.length; i++){
                    list.push(tail[i]);
                }
                return list;
            }

/* this unusual structure is due to the operator precedence rules*/
expression = binaryExpression
binaryExpression = asExpression
nonBinaryExpression = functionCall
            / functionExpression
            / unaryExpression
            / primary

            /*
            / cond:expression 'if' trueval:expression 'else' falseval:expression
            / listComprehension
            */

unaryExpression = op:('-' / 'not') exp:nonBinaryExpression
                    { return new UnaryExpression(op, exp); }

asExpression = lefts:(exp:orExpression _ 
                op:(op:'as' _nonchar_ {
                        return {op:op, pos:getCurrentPos(),
                            endPos : getCurrentEndPos()};}) _ 
                    { return {exp:exp, op:op.op, pos:op.pos,
                        endPos : op.endPos}; })*
                right:orExpression
                { return leftAssociative(lefts, right); }

orExpression = lefts:(exp:andExpression _ 
                op:(op:'or' _nonchar_ { 
                    return {op:op, pos:getCurrentPos(),
                        endPos : getCurrentEndPos()};}) _ 
                    { return {exp:exp, op:op.op, pos:op.pos,
                        endPos:op.endPos};})*
                right:andExpression
                { return leftAssociative(lefts, right); }

andExpression = lefts:(exp:inExpression _
                op:(op:'and' _nonchar_ {return {op:op, pos:getCurrentPos(), 
                        endPos : getCurrentEndPos()};}) _ 
                    { return {exp:exp, op:op.op, pos:op.pos,
                        endPos:op.endPos}; })*
                right:inExpression
                { return leftAssociative(lefts, right); }

inExpression = lefts:(exp:eqExpression _ 
                op:(op:'in' _nonchar_ { return {op:op, pos:getCurrentPos(), 
                        endPos : getCurrentEndPos()};}) _
                    { return {exp:exp, op:op.op, pos:op.pos,
                        endPos:op.endPos}; })*
                right:eqExpression
                { return leftAssociative(lefts, right); }

eqExpression = lefts:(exp:cmpExpression _ 
                op:(op:('=' / '!=' / isop:'is' _nonchar_ {return isop;} )
                    { return { op:op, pos:getCurrentPos(),
                        endPos : getCurrentEndPos()} }) _ 
                    { return {exp:exp, op:op.op, pos:op.pos,
                        endPos:op.endPos}; })*
                right:cmpExpression
                { return leftAssociative(lefts, right); }

cmpExpression = lefts:(exp:addExpression _ 
                op:(op:('<=' / '>=' / '<' / '>') 
                    { return {op:op, pos:getCurrentPos(),
                        endPos : getCurrentEndPos()}; }) _
                    { return {exp:exp, op:op.op, pos:op.pos,
                        endPos:op.endPos}; })*
                right:addExpression
                { return leftAssociative(lefts, right); }

addExpression = lefts:(exp:mulExpression _ 
                op:(_nocompound_ op:('+' / '-')
                    {return {op:op, pos:getCurrentPos(),
                        endPos : getCurrentEndPos()};}) _
                    { return {exp:exp, op:op.op, pos:op.pos,
                        endPos:op.endPos}; })*
                right:mulExpression
                { return leftAssociative(lefts, right); }

mulExpression = lefts:(exp:powExpression _ 
                op:(_nocompound_ op:('*' / '/' / '%' )
                    { return { op:op, pos:getCurrentPos(), 
                        endPos : getCurrentEndPos() }; }) _ 
                    { return {exp:exp, op:op.op, pos:op.pos,
                        endPos:op.endPos}; })*
                right:powExpression
                { return leftAssociative(lefts, right); }

powExpression = left:memberAccess rights:( _ _nocompound_ op:(op:'^'
                { return { op:op, pos:getCurrentPos(), 
                        endPos : getCurrentEndPos() }; } ) _
                exp:memberAccess
                    { return {op:op.op, exp:exp, pos:op.pos, 
                        endPos : op.endPos} })*
                { return rightAssociative(left, rights); }

memberAccess = lefts:(exp:nonBinaryExpression _ 
                op:(op:'.' { return { op:op, pos:getCurrentPos(),
                        endPos : getCurrentEndPos()}; }) _
                    { return {exp:exp, op:op.op, pos:op.pos,
                        endPos:op.endPos}; })*
                right:nonBinaryExpression
                { return leftAssociative(lefts, right); }

functionExpression = Lparenthesis parameterListWithoutDefaults? Rparenthesis '->' expression

primary = Lparenthesis exp:expression Rparenthesis { return exp }
        / literal
        / 'self' _nonchar_ _ { return new SelfExpression(getCurrentPos(),
                                        getCurrentEndPos()); }
        / name:Identifier { return new VariableAccess(getCurrentPos(),
                                        getCurrentEndPos(), name); }
        / name:ConstantIdentifier
            { return new VariableAccess(getCurrentPos(),
                                        getCurrentEndPos(), name); }
        // 'parent(' parent:type ')'

literal = IntLiteral
        / FloatLiteral
        / CharLiteral
        / StringLiteral
        / BoolLiteral
/*  / arrayLiteral
  / rangeLiteral
  / tupleLiteral*/

/*rangeLiteral
  : Lbracket expression '..' expression Rbracket
  ;

arrayLiteral
  : Lbracket (expression (',' expression)*)? Rbracket
  ;

tupleLiteral
  : Lparenthesis (expression (',' expression)+)? Rparenthesis
  ;

listComprehension
  : Lbracket type expression '/' listGenerator ( ',' listGenerator)? Rbracket
  ;

listGenerator
  : Identifier 'in' expression listFilter?
  ;

listFilter
  : 'if' expression
  ;
*/


/* pattern matching */

/*
caseStatement
  : 'case' expression 'of' caseBlock
  ;

caseBlock
  : INDENT
      (pattern block)+
    DEDENT
  ;

patternGuard
  : 'if' expression
  ;

pattern
  : (typedPattern
  / '_'
  / compoundPattern
  / expression) patternGuard?
  ;

typedPattern
  : type Identifier
  / type ('_')?
  ;

compoundPattern
  : type? '(' patternList? ')'
  ;

patternList
  : pattern (',' pattern )*
  ;
*/


// ----------------------------------------------

BoolLiteral = value:('true' / 'false')
            { return new Literal(getCurrentPos(), getCurrentEndPos(),
                                value == 'true', "Bool");}

// --- Number Literals -----------------------------------------------

IntLiteral = firstDigit:Digit 
            digits:(Digit / Letter)*
            base:Base?
            {
                var numString = firstDigit+digits.join("");
                var baseNum = 10;
                if(base != null){
                    baseNum = convertToInt(base, 10);
                }
                return new Literal(getCurrentPos(), getCurrentEndPos(),
                                    convertToInt(numString, baseNum), "Int");
            }

FloatLiteral = FloatPointLiteral / FloatExponentLiteral
FloatPointLiteral = int:Digit* '.' frac:Digit*
                    {
                        return new Literal(getCurrentPos(), getCurrentEndPos(),
                                    parseFloat(int.join("")+"."+frac.join("")),
                                    "Float");
                    }
FloatExponentLiteral = int:Digit* e:[Ee] sign:[+-]? exp:Digit*
                    {
                        if(sign == null){sign = "+";}
                        return new Literal(getCurrentPos(), getCurrentEndPos(),
                            parseFloat(int.join("")+e+sign+exp.join("")),
                            "Float");
                    }

Base = '_' base:Digit+ {return base.join("")}
  

// -------------------------------------------------------------------
// -- String and Character Literals ----------------------------------
// -------------------------------------------------------------------

StringLiteral = raw:'raw'? '"' content:(StringEscapeSequence
                                    / ((!'\\' !'"' !'\n' !'\r') .))* '"'
                {return new Literal(getCurrentPos(), getCurrentEndPos(),
                                    flattenStringLiteral(content, raw=="raw"),
                                    "String");}

CharLiteral = '\'' content:(StringEscapeSequence
                            / ((!'\\' !'\'' !'\n' !'\r') .)) '\''
                {return new Literal(getCurrentPos(), getCurrentEndPos(),
                                    flattenStringLiteral(content, false),
                                    "Char");}
                
StringEscapeSequence = slash:'\\'
                    esc:('t' / 'b' / 'n' / 'r' / 'f' / '\'' / '\"' / '\\' 
                    / ('u' HexDigit HexDigit HexDigit HexDigit )
                    / ('x' HexDigit HexDigit ))
                    { return Array.isArray(esc)
                                ? slash+esc.join("")
                                : slash+esc; }

HexDigit = [0-9A-Fa-f]

// -------------------------------------------------------------------
// -- Identifiers ----------------------------------------------------
// -------------------------------------------------------------------

Identifier = a:'_'*
             b:LowercaseLetter
             c:IdentifierCharacter*
             {return a.join("")+b+c.join("");}
ConstantIdentifier = a:'_'*
                     b:UppercaseLetter
                     c:( UppercaseLetter / Digit / '_' )*
                     {return a.join("")+b+c.join("");}
ClassIdentifier = a:UppercaseLetter
                  b:NonLowercaseIdentifierCharacter*
                  c:LowercaseLetter
                  d:IdentifierCharacter*
                  {return a+b.join("")+c+d.join("")}
IdentifierCharacter = LowercaseLetter / UppercaseLetter / Digit / '_'
NonLowercaseIdentifierCharacter = UppercaseLetter / Digit / '_'

Digit = [0-9]
Letter = [a-zA-Z]
LowercaseLetter = [a-z]
UppercaseLetter = [A-Z]

// -- EOL INDENT DEDENT ----------------------------------

EOL = _  CRLF /* eat at least one EOL */
    /* eat as many empty lines and comment lines as possible */
    EmptyLineOrComment*
    /* eat a number of WS and check against the current indentation level */
    indent:([ \t]*)
    {
        var newIndent = indent.join("");
        if(newIndent != indentStack.peek()){
            if(newIndent.length > indentStack.peek().length){
                nextIsIndent = true;
                indentStack.push(newIndent);
            }
            else{
                var dedents = 0;
                while(newIndent != indentStack.peek()){
                    if(indentStack.length == 0){
                        throw new SyntaxError("invalid indentation in line "
                            +location().end.line);
                    }
                    indentStack.pop()
                    dedents++;
                }
                dedentCount = dedents;
            }
        }
    }


EmptyLineOrComment =  _ ('//' (!CRLF .)*)? CRLF
CRLF = ('\r\n' / '\r' / '\n')

/*EOL = _ ('\r\n' / '\r' / '\n')+ { return "EOL"; }*/

SAMEDENT = !{ return (nextIsIndent || (dedentCount > 0));}
    {return "SAMEDENT";}

INDENT = &{ return nextIsIndent; }
      { nextIsIndent = false; return "INDENT";}

DEDENT = &{ return (dedentCount > 0); }
        { dedentCount--; return "DEDENT"; }

// -- brackets --------------------------------------------

Lparenthesis = _ '(' _ {return null;}
Rparenthesis = _ ')' _ {return null;}
Lbracket = _ '[' _ {return null;}
Rbracket = _  ']'_  {return null;}
Lcurly = _ '{' _ {return null;}
Rcurly = _ '}' _ {return null;}

// ------- spaces --------------------------------------------

block = ':' EOL INDENT
            firstStatement:(statement / 'pass' EOL {return null;})
            statements:(SAMEDENT _ stmt:statement {return stmt;})* DEDENT
        {
            var body = []
            if(firstStatement){
                body.push(firstStatement);
            }
            if(Array.isArray(statements)){
                body = body.concat(statements);
            }
            return new Block(getCurrentPos(), getCurrentEndPos(), body);
        }

// -- white spaces --------------------------------------------

_ = (' ' / '\t' )* { return null; }
__ = (' ' / '\t' )+ { return null; }
_n = (' ' / '\t' / '\r' / '\n')* { return null; }
_nonchar_ = !([a-zA-Z]) { return null; }
_nocompound_ = !(compoundSymbol '=')


//if true:
//    foo()
//    if false:
//        bla()
//    plopp()
//fasel()
